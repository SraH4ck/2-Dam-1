[[Manejo de ficheros]]

----
#### Operaciones sobre Ficheros

Las operaciones más comunes que se realizan sobre ficheros, independientemente de cómo se acceda a ellos (secuencial o aleatorio), incluyen **creación**, **apertura**, **cierre**, **lectura** y **escritura**. Además, hay operaciones adicionales como **altas**, **bajas**, **modificaciones** y **consultas**. A continuación se describe cada una:

---

### Operaciones Básicas

1. **Creación del Fichero**:
    
    - La **creación** de un fichero consiste en asignar un espacio en el disco con un nombre específico que identificará dicho fichero.
    - **Este proceso solo se realiza una vez**, y una vez creado, el fichero puede abrirse y manipularse tantas veces como sea necesario. Ejemplo en Java
      ```java
      File file = new File("archivo.txt");
if (file.createNewFile()) {
    System.out.println("Fichero creado: " + file.getName());
} else {
    System.out.println("El fichero ya existe.");
}

```

2. **Apertura del Fichero**:

- Para poder operar con un fichero, es necesario **abrirlo primero**. Esto se logra identificando el fichero con el que se desea trabajar y asignándolo a una variable.
- En Java, la apertura se realiza al crear un objeto asociado con el fichero, como `FileReader`, `FileWriter`, `RandomAccessFile`, entre otros.
- Ejemplo de apertura para lectura
  ```java
  FileReader fr = new FileReader("archivo.txt");

```

3. **Cierre del Fichero**:

- Después de utilizar un fichero, **se debe cerrar**. Esto libera los recursos asociados al fichero y asegura que cualquier operación pendiente, como escribir datos en el disco, se complete.
- En Java, se utiliza el método `close()` para cerrar el fichero. Ejemplo
  ```java
  fr.close() //Cierra el FileReader
```

4. **Lectura de Datos del Fichero**:

- La lectura consiste en **transferir datos** del fichero a la **memoria principal** del programa, que suele ser gestionada mediante variables.
- Ejemplo de lectura en Java (secuencial)
  ```java
  BufferedReader br = new BufferedReader(new FileReader("archivo.txt"));
String linea;
while ((linea = br.readLine()) != null) {
    System.out.println(linea);  // Procesa cada línea
}
br.close();

```

5. **Escritura de Datos en el Fichero**:

- La escritura consiste en **transferir datos** desde la memoria del programa al fichero. Esto puede ser realizado de forma secuencial o aleatoria. Ejemplo:
  ```java
  BufferedWriter bw = new BufferedWriter(new FileWriter("archivo.txt"));
bw.write("Este es un nuevo dato.");
bw.close();  // Cierra después de escribir
```

### Operaciones Típicas

1. **Altas**:
    
    - Consiste en **añadir un nuevo registro** al fichero. En ficheros secuenciales, los nuevos datos se añaden al final.
    - Ejemplo en Java
      ```java 
      FileWriter fw = new FileWriter("archivo.txt", true);  // "true" permite añadir al final
BufferedWriter bw = new BufferedWriter(fw);
bw.write("Nuevo registro");
bw.close();

```

2. **Bajas**:

- La baja consiste en **eliminar un registro existente** en el fichero.
- **Eliminación lógica**: Se marca el registro como inactivo sin borrarlo físicamente. Puede hacerse cambiando un valor de un campo.
- **Eliminación física**: Se reescribe el fichero eliminando el registro no deseado.
- Ejemplo de eliminación física:
  
```java
File original = new File("archivo.txt");
File temporal = new File("archivo_tmp.txt");
BufferedReader br = new BufferedReader(new FileReader(original));
BufferedWriter bw = new BufferedWriter(new FileWriter(temporal));

String linea;
while ((linea = br.readLine()) != null) {
    if (!linea.contains("registro a eliminar")) {
        bw.write(linea + System.lineSeparator());
    }
}
br.close();
bw.close();
original.delete();
temporal.renameTo(original);  // Renombra temporal al nombre original

```

3. **Modificaciones**:

- La modificación de un registro consiste en **cambiar parte del contenido** de un registro existente. En muchos casos, se requiere localizar el registro y luego reescribirlo. Ejemplo de modificación
  ```java
  RandomAccessFile raf = new RandomAccessFile("archivo.dat", "rw");
raf.seek(100);  // Posiciona en el byte 100
raf.writeUTF("Nuevo contenido");  // Sobrescribe en esa posición
raf.close();

```

4. **Consultas**:

- Consiste en **buscar un registro** dentro del fichero sin modificar su contenido. Esto implica recorrer el fichero hasta encontrar el dato que se desea. Ejemplo:
  ```java
  BufferedReader br = new BufferedReader(new FileReader("archivo.txt"));
String linea;
while ((linea = br.readLine()) != null) {
    if (linea.contains("dato buscado")) {
        System.out.println("Registro encontrado: " + linea);
    }
}
br.close();

```

---
### Resumen de las Operaciones:

- **Creación**: Se realiza una sola vez para inicializar el fichero.
- **Apertura**: Es necesaria antes de cualquier operación de lectura o escritura.
- **Cierre**: Se debe realizar siempre después de usar el fichero para liberar los recursos.
- **Lectura/Escritura**: Operaciones básicas que permiten interactuar con el contenido del fichero.
- **Altas**: Añadir nuevos registros.
- **Bajas**: Eliminar registros, puede ser lógico o físico.
- **Modificaciones**: Actualizar el contenido de un registro existente.
- **Consultas**: Buscar un registro específico sin modificar el fichero.

----

#### 1.5.1. Operaciones sobre Ficheros Secuenciales

En los ficheros secuenciales, los registros se insertan en **orden cronológico**, lo que significa que los nuevos registros siempre se añaden al final. Este tipo de ficheros es adecuado cuando el procesamiento de registros se realiza en **lotes** y de manera secuencial, ya que permiten un acceso rápido al siguiente registro, pero tienen limitaciones en términos de actualización y acceso directo.

---

### Operaciones Típicas en Ficheros Secuenciales

1. **Consultas**:
    
    - Para **consultar un registro específico** en un fichero secuencial, es necesario leer **todos los registros** desde el principio hasta llegar al que se busca.
    - Ejemplo: Si se quiere acceder al registro 90, será necesario leer los primeros 89 registros antes de llegar a él.
    - **Desventaja**: **No es posible acceder directamente** a un registro, se debe realizar un recorrido secuencial completo hasta encontrarlo.
    - **Ejemplo en Java** para lectura secuencial
      ```java
      BufferedReader br = new BufferedReader(new FileReader("archivo.txt"));
String linea;
int contador = 0;
while ((linea = br.readLine()) != null) {
    contador++;
    if (contador == 90) {
        System.out.println("Registro 90: " + linea);
        break;
    }
}
br.close();

```

2. **Altas**:

- Las **altas** en un fichero secuencial se realizan **siempre al final** del último registro existente, lo que implica que no se puede insertar un registro en medio de los ya existentes.
- **Ventaja**: Esta operación es rápida, ya que se aprovecha el hecho de que el nuevo registro simplemente se agrega al final.
- **Ejemplo en Java** para añadir un registro al final del fichero:
  ```java
  BufferedWriter bw = new BufferedWriter(new FileWriter("archivo.txt", true));
bw.write("Nuevo registro al final");
bw.close();

```

3. **Bajas**:

- Para realizar una **baja** en un fichero secuencial, se debe:
    1. Leer el fichero original **registro por registro**.
    2. Escribir los registros en un **fichero auxiliar**, excepto el que se desea eliminar.
    3. Borrar el fichero original.
    4. Renombrar el fichero auxiliar con el nombre del fichero original.
- **Desventaja**: Este proceso es **lento**, ya que implica la reescritura completa del fichero.
- **Ejemplo en Java** para eliminar un registro
  ```java
  File original = new File("archivo.txt");
File auxiliar = new File("archivo_auxiliar.txt");

BufferedReader br = new BufferedReader(new FileReader(original));
BufferedWriter bw = new BufferedWriter(new FileWriter(auxiliar));

String linea;
while ((linea = br.readLine()) != null) {
    if (!linea.contains("Registro a eliminar")) {
        bw.write(linea + System.lineSeparator());
    }
}
br.close();
bw.close();

original.delete();
auxiliar.renameTo(original);

```

4. **Modificaciones**:

- Las **modificaciones** en ficheros secuenciales siguen un proceso similar al de las bajas:
    1. Se lee el fichero original.
    2. Se escribe en un fichero auxiliar, pero modificando el registro que se desea actualizar.
    3. Se reemplaza el fichero original por el auxiliar.
- **Desventaja**: Al igual que con las bajas, este proceso implica **reescribir todo el fichero**, lo que puede ser ineficiente para grandes volúmenes de datos.
- **Ejemplo en Java** para modificar un registro:
  ```java File original = new File("archivo.txt");
File auxiliar = new File("archivo_auxiliar.txt");

BufferedReader br = new BufferedReader(new FileReader(original));
BufferedWriter bw = new BufferedWriter(new FileWriter(auxiliar));

String linea;
while ((linea = br.readLine()) != null) {
    if (linea.contains("Registro a modificar")) {
        bw.write("Registro modificado" + System.lineSeparator());
    } else {
        bw.write(linea + System.lineSeparator());
    }
}
br.close();
bw.close();

original.delete();
auxiliar.renameTo(original);

```

### Ventajas y Desventajas de los Ficheros Secuenciales

- **Ventajas**:
    
    - **Acceso rápido al siguiente registro**: Cuando se necesita leer el fichero de manera secuencial, los ficheros secuenciales ofrecen una excelente velocidad.
    - **Optimización del espacio**: Utilizan eficientemente el espacio en disco, ya que los registros se almacenan de forma compacta.
    - **Simplicidad**: Son fáciles de usar, lo que los hace adecuados para aplicaciones de **procesamiento por lotes** como los backups de datos.
- **Desventajas**:
    
    - **No permiten acceso directo**: Si se necesita acceder a un registro específico, se debe leer secuencialmente todo el fichero hasta encontrarlo.
    - **Actualizaciones ineficientes**: Para modificar, eliminar o insertar registros, es necesario **reescribir el fichero completo**, lo que resulta lento e ineficiente en ficheros grandes.
    - **Poco adecuados para aplicaciones interactivas**: En aplicaciones donde se realizan consultas o actualizaciones frecuentes sobre registros individuales, los ficheros secuenciales ofrecen **un rendimiento pobre**.

---

### Uso Típico de Ficheros Secuenciales

Los ficheros secuenciales se utilizan principalmente en situaciones donde:

- **Todos los registros se procesan** de manera secuencial, como en copias de seguridad o en análisis de grandes volúmenes de datos.
- Se prioriza la **eficiencia en el acceso secuencial** y no es necesario acceder a registros individuales de forma aleatoria.

---

#### 1.5.2. Operaciones sobre Ficheros Aleatorios

En los **ficheros aleatorios**, el acceso a los registros se realiza directamente mediante su **posición relativa** dentro del fichero, lo que permite leer y escribir datos de manera **rápida** sin necesidad de recorrer todo el fichero. Este tipo de acceso utiliza una **función de conversión** basada en la **clave** del registro y el **tamaño** del mismo, facilitando el acceso a un registro específico de forma directa. Sin embargo, la gestión de las posiciones y el uso de una **zona de excedentes** para los conflictos de inserción hacen que este sistema sea más complejo.

---

### Operaciones Típicas en Ficheros Aleatorios

1. **Consultas**:
    
    - Para **consultar un registro** en un fichero aleatorio, es necesario:
        1. Conocer la **clave** del registro (un campo identificador único).
        2. Aplicar una **función de conversión** a la clave para obtener la posición del registro en el fichero.
        3. Leer el registro ubicado en la posición devuelta.
    - **Zona de Excedentes**: Si la posición devuelta por la función de conversión ya está ocupada por otro registro, el registro buscado puede encontrarse en una **zona de excedentes**.
    - **Ventaja**: El acceso es **rápido y directo** a un registro específico, sin necesidad de recorrer secuencialmente el fichero.
    - **Ejemplo en Java** usando la clase `RandomAccessFile`:
      ```java
      RandomAccessFile raf = new RandomAccessFile("empleados.dat", "r");
int id = 2;  // Identificador del empleado que se busca
long posicion = (id - 1) * 48;  // Suponiendo registros de 48 bytes
raf.seek(posicion);  // Nos posicionamos en el registro
String apellido = raf.readUTF();  // Leemos el apellido
double salario = raf.readDouble();  // Leemos el salario
raf.close();
System.out.println("Empleado ID: " + id + ", Apellido: " + apellido + ", Salario: " + salario);

```

2. **Altas**:

- Para realizar una **alta** en un fichero aleatorio:
    1. Se aplica la **función de conversión** a la clave para obtener la posición donde se va a insertar el registro.
    2. Si la posición calculada está ocupada, se inserta el registro en la **zona de excedentes**.
- **Ventaja**: Permite la **inserción directa** en la posición correspondiente, evitando recorrer todo el fichero.
- **Desventaja**: Si hay **conflictos de posición**, se necesita gestionar la zona de excedentes, lo que complica la administración del fichero.
- **Ejemplo en Java** para insertar un nuevo registro:
  ```java
  RandomAccessFile raf = new RandomAccessFile("empleados.dat", "rw");
int id = 4;  // Nuevo identificador del empleado
long posicion = (id - 1) * 48;  // Posición del nuevo registro
raf.seek(posicion);  // Posicionamos en la ubicación
raf.writeUTF("Perez");  // Escribimos apellido
raf.writeDouble(3500.0);  // Escribimos salario
raf.close();

```

3. **Bajas**:

- Las **bajas** en ficheros aleatorios suelen ser **lógicas**:
    1. Se localiza el registro mediante la clave.
    2. Se cambia un **campo de control** (un switch) para indicar que el registro ha sido eliminado.
- **Desventaja**: Aunque el registro está **lógicamente eliminado**, **físicamente** sigue ocupando espacio en el fichero.
- **Ejemplo en Java** para realizar una baja lógica:
  ```java 
RandomAccessFile raf = new RandomAccessFile("empleados.dat", "rw");
int id = 3;  // Identificador del empleado a dar de baja
long posicion = (id - 1) * 48;  // Posición del registro a eliminar
raf.seek(posicion);  // Nos posicionamos en el registro
raf.writeUTF("**ELIMINADO**");  // Cambiamos el apellido para indicar baja
raf.close();
```

4. **Modificaciones**:

- Para **modificar un registro**:
    1. Se localiza el registro usando la **clave**.
    2. Se accede a la posición correspondiente.
    3. Se realizan las modificaciones necesarias y se reescribe el registro en la misma posición.
- **Ventaja**: Permite modificar un registro específico sin necesidad de alterar el resto del fichero.
- Ejemplo:
  ```java
  RandomAccessFile raf = new RandomAccessFile("empleados.dat", "rw");
int id = 2;  // Identificador del empleado a modificar
long posicion = (id - 1) * 48;  // Posición del registro
raf.seek(posicion);  // Nos posicionamos en el registro
raf.writeUTF("Garcia");  // Cambiamos el apellido
raf.writeDouble(4500.0);  // Cambiamos el salario
raf.close();

```

----
### Ventajas y Desventajas de los Ficheros Aleatorios

- **Ventajas**:
    
    - **Acceso directo**: Permite acceder a un registro específico de manera **rápida**, sin necesidad de recorrer el fichero secuencialmente.
    - **Actualización eficiente**: Modificar o consultar un registro es más **eficiente** que en los ficheros secuenciales, ya que se puede **reescribir en su posición** directamente.
- **Desventajas**:
    
    - **Gestión compleja**: La administración de las posiciones y la gestión de la **zona de excedentes** puede ser complicada.
    - **Espacio desperdiciado**: Es posible que haya **espacios no utilizados** en el fichero (huecos) debido a las bajas lógicas y a los conflictos de posición.
    - **Fragmentación**: La necesidad de utilizar zonas de excedentes puede provocar **fragmentación**, dificultando el mantenimiento del fichero a largo plazo.

---

### Uso Típico de Ficheros Aleatorios

Los ficheros aleatorios se utilizan principalmente en situaciones donde:

- Se necesita **acceso directo** a registros específicos (por ejemplo, en **bases de datos de empleados** o **sistemas de inventario**).
- Se requiere realizar **consultas, modificaciones o actualizaciones frecuentes** en registros individuales.
- La eficiencia del acceso es **crítica**, y no es posible recorrer secuencialmente un gran volumen de datos.